// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package telemetry

import (
	"sync"
)

// Ensure, that TelemeterMock does implement Telemeter.
// If this is not the case, regenerate this file with moq.
var _ Telemeter = &TelemeterMock{}

// TelemeterMock is a mock implementation of Telemeter.
//
//	func TestSomethingThatUsesTelemeter(t *testing.T) {
//
//		// make and configure a mocked Telemeter
//		mockedTelemeter := &TelemeterMock{
//			GroupFunc: func(groupID string, userID string, props map[string]any)  {
//				panic("mock out the Group method")
//			},
//			IdentifyFunc: func(userID string, props map[string]any)  {
//				panic("mock out the Identify method")
//			},
//			StopFunc: func()  {
//				panic("mock out the Stop method")
//			},
//			TrackFunc: func(event string, userID string, props map[string]any)  {
//				panic("mock out the Track method")
//			},
//		}
//
//		// use mockedTelemeter in code that requires Telemeter
//		// and then make assertions.
//
//	}
type TelemeterMock struct {
	// GroupFunc mocks the Group method.
	GroupFunc func(groupID string, userID string, props map[string]any)

	// IdentifyFunc mocks the Identify method.
	IdentifyFunc func(userID string, props map[string]any)

	// StopFunc mocks the Stop method.
	StopFunc func()

	// TrackFunc mocks the Track method.
	TrackFunc func(event string, userID string, props map[string]any)

	// calls tracks calls to the methods.
	calls struct {
		// Group holds details about calls to the Group method.
		Group []struct {
			// GroupID is the groupID argument value.
			GroupID string
			// UserID is the userID argument value.
			UserID string
			// Props is the props argument value.
			Props map[string]any
		}
		// Identify holds details about calls to the Identify method.
		Identify []struct {
			// UserID is the userID argument value.
			UserID string
			// Props is the props argument value.
			Props map[string]any
		}
		// Stop holds details about calls to the Stop method.
		Stop []struct {
		}
		// Track holds details about calls to the Track method.
		Track []struct {
			// Event is the event argument value.
			Event string
			// UserID is the userID argument value.
			UserID string
			// Props is the props argument value.
			Props map[string]any
		}
	}
	lockGroup    sync.RWMutex
	lockIdentify sync.RWMutex
	lockStop     sync.RWMutex
	lockTrack    sync.RWMutex
}

// Group calls GroupFunc.
func (mock *TelemeterMock) Group(groupID string, userID string, props map[string]any) {
	if mock.GroupFunc == nil {
		panic("TelemeterMock.GroupFunc: method is nil but Telemeter.Group was just called")
	}
	callInfo := struct {
		GroupID string
		UserID  string
		Props   map[string]any
	}{
		GroupID: groupID,
		UserID:  userID,
		Props:   props,
	}
	mock.lockGroup.Lock()
	mock.calls.Group = append(mock.calls.Group, callInfo)
	mock.lockGroup.Unlock()
	mock.GroupFunc(groupID, userID, props)
}

// GroupCalls gets all the calls that were made to Group.
// Check the length with:
//
//	len(mockedTelemeter.GroupCalls())
func (mock *TelemeterMock) GroupCalls() []struct {
	GroupID string
	UserID  string
	Props   map[string]any
} {
	var calls []struct {
		GroupID string
		UserID  string
		Props   map[string]any
	}
	mock.lockGroup.RLock()
	calls = mock.calls.Group
	mock.lockGroup.RUnlock()
	return calls
}

// Identify calls IdentifyFunc.
func (mock *TelemeterMock) Identify(userID string, props map[string]any) {
	if mock.IdentifyFunc == nil {
		panic("TelemeterMock.IdentifyFunc: method is nil but Telemeter.Identify was just called")
	}
	callInfo := struct {
		UserID string
		Props  map[string]any
	}{
		UserID: userID,
		Props:  props,
	}
	mock.lockIdentify.Lock()
	mock.calls.Identify = append(mock.calls.Identify, callInfo)
	mock.lockIdentify.Unlock()
	mock.IdentifyFunc(userID, props)
}

// IdentifyCalls gets all the calls that were made to Identify.
// Check the length with:
//
//	len(mockedTelemeter.IdentifyCalls())
func (mock *TelemeterMock) IdentifyCalls() []struct {
	UserID string
	Props  map[string]any
} {
	var calls []struct {
		UserID string
		Props  map[string]any
	}
	mock.lockIdentify.RLock()
	calls = mock.calls.Identify
	mock.lockIdentify.RUnlock()
	return calls
}

// Stop calls StopFunc.
func (mock *TelemeterMock) Stop() {
	if mock.StopFunc == nil {
		panic("TelemeterMock.StopFunc: method is nil but Telemeter.Stop was just called")
	}
	callInfo := struct {
	}{}
	mock.lockStop.Lock()
	mock.calls.Stop = append(mock.calls.Stop, callInfo)
	mock.lockStop.Unlock()
	mock.StopFunc()
}

// StopCalls gets all the calls that were made to Stop.
// Check the length with:
//
//	len(mockedTelemeter.StopCalls())
func (mock *TelemeterMock) StopCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockStop.RLock()
	calls = mock.calls.Stop
	mock.lockStop.RUnlock()
	return calls
}

// Track calls TrackFunc.
func (mock *TelemeterMock) Track(event string, userID string, props map[string]any) {
	if mock.TrackFunc == nil {
		panic("TelemeterMock.TrackFunc: method is nil but Telemeter.Track was just called")
	}
	callInfo := struct {
		Event  string
		UserID string
		Props  map[string]any
	}{
		Event:  event,
		UserID: userID,
		Props:  props,
	}
	mock.lockTrack.Lock()
	mock.calls.Track = append(mock.calls.Track, callInfo)
	mock.lockTrack.Unlock()
	mock.TrackFunc(event, userID, props)
}

// TrackCalls gets all the calls that were made to Track.
// Check the length with:
//
//	len(mockedTelemeter.TrackCalls())
func (mock *TelemeterMock) TrackCalls() []struct {
	Event  string
	UserID string
	Props  map[string]any
} {
	var calls []struct {
		Event  string
		UserID string
		Props  map[string]any
	}
	mock.lockTrack.RLock()
	calls = mock.calls.Track
	mock.lockTrack.RUnlock()
	return calls
}
